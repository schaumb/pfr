#!/usr/bin/python

# Copyright (c) 2016-2022 Antony Polukhin
#
# Distributed under the Boost Software License, Version 1.0. (See accompanying
# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

############################################################################################################################

import sys
import string

# Skipping some letters that may produce keywords or are hard to read, or shadow template parameters
ascii_letters = string.ascii_letters.replace("o", "").replace("O", "").replace("i", "").replace("I", "").replace("T", "")

PROLOGUE = """// Copyright (c) 2016-2022 Antony Polukhin
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////// THIS HEADER IS AUTO GENERATED BY misc/generate_cpp17.py                                    ////////////////
//////////////// MODIFY AND RUN THE misc/generate_cpp17.py INSTEAD OF DIRECTLY MODIFYING THE GENERATED FILE ////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef BOOST_PFR_DETAIL_CORE17_GENERATED_HPP
#define BOOST_PFR_DETAIL_CORE17_GENERATED_HPP
#pragma once

#include <boost/pfr/detail/config.hpp>
#if !BOOST_PFR_USE_CPP17
#   error C++17 is required for this header.
#endif

#include <boost/pfr/detail/sequence_tuple.hpp>
#include <boost/pfr/detail/size_t_.hpp>

namespace boost { namespace pfr { namespace detail {
"""

########################################################################################################################

EPILOGUE = """
template <class T, std::size_t I>
constexpr void structure_member_getter_setter(T& /*val*/, size_t_<I>) noexcept {
  static_assert(sizeof(T) && false,
                "====================> Boost.PFR: Too many fields in a structure T. Regenerate include/boost/pfr/detail/core17_generated.hpp file for appropriate count of fields. For example: `python ./misc/generate_cpp17.py 300 > include/boost/pfr/detail/core17_generated.hpp`");
}

}}} // namespace boost::pfr::detail

#endif // BOOST_PFR_DETAIL_CORE17_GENERATED_HPP
"""

########################################################################################################################

indexes = []
print(PROLOGUE)
funcs_count = 100 if len(sys.argv) == 1 else int(sys.argv[1])
max_args_on_a_line = len(ascii_letters)
for i in range(0, funcs_count):
    if i % max_args_on_a_line == 0:
        indexes.append([])

    if i >= max_args_on_a_line:
        indexes[-1].append(ascii_letters[i // max_args_on_a_line - 1] + ascii_letters[i % max_args_on_a_line])
    else:
        indexes[-1] += ascii_letters[i % max_args_on_a_line]

    print("template <class T>")
    print("constexpr auto structure_member_getter_setter(T& val, size_t_<" + str(i + 1) + ">) noexcept {")
    print("  return std::pair { [&val] (auto is, auto ref) -> decltype(auto) {")

    def print_structure_binding():
        print("      static_assert(is() < " + str(i + 1) + ");")
        if len(indexes) == 1:
            print("      auto& [" + (",".join(indexes[0])) + "] = val; // ====================> Boost.PFR: User-provided type is not a SimpleAggregate.")
        else:
            print("      auto& [")
            print("        " + (",\n        ".join(map(lambda index_list: ",".join(index_list), indexes))))
            print("      ] = val; // ====================> Boost.PFR: User-provided type is not a SimpleAggregate.")

    print_structure_binding()

    index = 0
    for index_list in indexes:
        for index_name in index_list:
            print("      if constexpr (is() == " + str(index) + ") { if constexpr (ref()) return (" + index_name + "); else return " + index_name + "; }")
            index += 1

    print("    }, [&val] (auto is, auto&& assign) {")

    print_structure_binding()

    index = 0
    for index_list in indexes:
        for index_name in index_list:
            print("      if constexpr (is() == " + str(index) + ") { " + index_name + " = std::forward<decltype(assign)>(assign); }")
            index += 1

    print("    }")
    print("  };")
    print("}\n")

print(EPILOGUE)
